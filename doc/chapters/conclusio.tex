\chapter{Zusammenfassung}
In diesem Kapitel werden die behandelten Themen und die wichtigsten Erkenntnisse zusammengefasst.
\newline
% GraphQL ist sprachunabhängig, deshalb werden in der Spezifikation keine Implementierungsdetails definiert sondern nur Entwurfsprinzipien.
Die Spezifikation von GraphQL definiert Entwurfsprinzipien, macht aber keine Vorgaben zur Implementierung von GraphQL-Services.
% Die Spezifikation von GraphQL liefert keine Implementierungsdetails sondern lediglich Entwurfsprinzipien.
GraphQL beschreibt eine konkrete Architektur, REST wiederum beschreibt laut Fielding einen Architekturstil.
\newline

Wenn es darum geht komplexe strukturierte Daten zu verwalten, schneidet GraphQL besser ab.
Hier ist vor allem anzuführen, dass GraphQL Over- und Underfetching per Design verhindert.
% Denn GraphQL lagert die Komplexität, die Struktur der Daten festzulegen, an den Client aus.
GraphQL gibt, anders als REST-APIs, die Struktur der Daten nicht selbst vor, sondern lässt den Client die Struktur der benötigten Daten festlegen. 
Dadurch bekommt der Client immer genau jene Daten, die er benötigt.
Weiters beeinflusst GraphQL die Performanz des Clients positiv, indem der Netzwerkverkehr auf das Notwendigste reduziert wird.
Davon profitieren vor allem mobile Applikationen.
% Umso mehr verschiedene Clients verschiedene Anforderungen an die Struktur der Daten haben, desto gravierender tritt das Over- und Underfetching Problem bei REST-APIs auf.
% Dadurch beeinflusst GraphQL die Performanz des Clients positiv durch die Reduktion an notwendigen Netzwerkverkehr.
\newline

% GraphQL beschreibt mit dem Schema die Operationen welche am GraphQL-Service ausgeführt werden können
Die Zugriffsmöglichkeiten (Query, Mutation, Subscription) und die von GraphQL verwalteten Objekte werden in einem Schema definiert.
% Über die Geschäftslogik, welche für die Generierung der Daten notwendig ist, weiß das Schema
Aus dem Schema ist weder die Generierung der Daten noch die Manipulation dieser ableitbar.
Die Generierung und Manipulation der Daten übernehmen in GraphQL-Resolver, die je nach Frameowrk unterschiedlich implementiert werden.
Die Resolver stellen das Bindeglied zur Geschäftslogik dar.
Dadurch ist es möglich, einen GraphQL-Service neben einem bereits bestehenden REST-Service zu betreiben.
Die Resolver verwenden dabei die bereits bestehende Geschäftslogik.
\newline
% GraphQL zu bestehenden REST-Service Hinzufügen
% Dataloader löst 1 + n Problem

Es konnte ein prototypischer GraphQL-Service in .NET 6 mittels dem Framework HotChocolate erfolgreich umgesetzt werden.
Dieser Prototyp bietet Clients die Möglichkeit lesend als auch schreibend auf die verwalteten Daten zuzugreifen.
Weiters bietet der Prototyp bidirektionale Kommunikation zwischen Client und Server mittels Subscriptions.
Der Endpunkt des GraphQL-Client wurde gegen unbefugte Zugriffe mit einem JWT-Token abgesichert.
Dabei wurde auch die Autorisierung mittels Rollen, die im JWT-Token gespeichert werden, realisiert.
Der Prototyp implementiert eine Lösung für das \glqq1 + n Problem\grqq{} mittels eines Dataloaders.